--------------------------------------------------------------------------------
-- File containing model definition
--------------------------------------------------------------------------------
require "nn"
require "rnn" 
require "nngraph"
require "ShiftLearn"
local Model = {}

function Model.create(opt, addressReader, addressWriter, valueWriter)
   local vectorSize = tonumber(opt.vectorSize)
   local memSize = tonumber(opt.memorySize)
   local inputSize = 0
   if not opt.noInput then
      inputSize = tonumber(opt.inputSize)
   end
   local RNN_steps = 5 --TODO add command line param

   ----------------------------------------------------------------------------
   --  Initial Memory
   ----------------------------------------------------------------------------
   local initialMem = nn.Identity()()
   ----------------------------------------------------------------------------

   ----------------------------------------------------------------------------
   -- Input
   ----------------------------------------------------------------------------
   local input = nil

   if not opt.noInput then
      input = nn.Identity()()
   end
   ----------------------------------------------------------------------------
   

   ----------------------------------------------------------------------------
   --  Address Encoder
   ----------------------------------------------------------------------------
   local reshapedMem = nn.Reshape(memSize * vectorSize)(initialMem)

   --TODO here comes custom address reader
   local AR = nn.GRU 
   if addressReader then
      AR = addressReader
      params = {}
   end
   local enc = AR(memSize * vectorSize, memSize, RNN_steps)(reshapedMem)
   local address = nn.SoftMax()(enc)
   ----------------------------------------------------------------------------


   ----------------------------------------------------------------------------
   -- Value Extractor
   ----------------------------------------------------------------------------

   local addressTransp = nn.Reshape(1, memSize)(address)
   local value = nn.MM()({addressTransp, initialMem})
   ----------------------------------------------------------------------------

   ----------------------------------------------------------------------------
   -- Next address calculator
   ----------------------------------------------------------------------------
   local reshapedValue = nn.Squeeze(1)(value)
   local inputValAddr = nil
   if not opt.noInput then
      local inputVal = nn.JoinTable(1)({input, address})
      inputValAddr = nn.JoinTable(1)({inputVal, reshapedValue})
   else
      inputValAddr = nn.JoinTable(1)({address, reshapedValue})
   end
   --TODO add custom addresss Writer
   local AW = nn.GRU
   if addressWriter then
      AW = addressWriter
   end
   local addrCalc =
      AW(inputSize + memSize + vectorSize, memSize, RNN_steps)(inputValAddr)
   ----------------------------------------------------------------------------


   ----------------------------------------------------------------------------
   -- Next value calculator
   ----------------------------------------------------------------------------
   
   -- TODO add custom value writer 
   local VW = nn.GRU
   if valueWriter then
      VW = valueWriter
   end
   local valueCalc = VW(inputSize + memSize + vectorSize, vectorSize, RNN_steps)
      (inputValAddr)
   ----------------------------------------------------------------------------

   ----------------------------------------------------------------------------
   -- Memory Calculator
   ----------------------------------------------------------------------------

   -- adder
   local resizeValueCalc = nn.Reshape(1, vectorSize)(valueCalc)
   local resizeAddrCalc = nn.Reshape(memSize, 1)(addrCalc)
   local adder = nn.MM()({resizeAddrCalc, resizeValueCalc})


   -- eraser
   local addrCalcTransp = nn.Reshape(1, memSize)(addrCalc)
   local AT_M_t_1 =  nn.MM()({addrCalcTransp, initialMem})
   local resAddrCalc = nn.Reshape(memSize, 1)(addrCalc)
   local AAT_M_t_1 = nn.MM()({resAddrCalc, AT_M_t_1})

   -- memory update
   local memEraser = nn.CSubTable()({initialMem, AAT_M_t_1})
   local finMem = nn.CAddTable()({memEraser, adder})
   ----------------------------------------------------------------------------

   if opt.noProb then
      if opt.noInput then
         return nn.gModule({initialMem}, {finMem})
      end
      return nn.gModule({initialMem, input}, {finMem})
   end

   ----------------------------------------------------------------------------
   -- Probability calculator
   ----------------------------------------------------------------------------
   local addrValCalc = nn.JoinTable(1)({addrCalc, valueCalc})
   local allInOne = nn.JoinTable(1)({addrValCalc, reshapedMem})

   --TODO maybe this could be generalized as well
   local h1 = nn.Linear(vectorSize + memSize + memSize * vectorSize, 10)
   (allInOne) -- hidden layer
   
   local p = nn.Sigmoid()(nn.Linear(10, 1)(nn.Sigmoid()(nn.Linear(10, 10)(
   nn.Sigmoid()(h1)))))

   if opt.NRAMProb then
      local prevDelta = nn.Identity()()
      local pNRAM = nn.MM()({nn.Reshape(1,1)(p), nn.Reshape(1,1)(prevDelta)})
      if opt.noInput then
         return nn.gModule({initialMem, prevDelta}, {finMem, p, pNRAM})
      end
      return nn.gModule({initialMem, input, prevDelta}, {finMem, p, pNRAM})

   end
   ----------------------------------------------------------------------------

   return nn.gModule({initialMem, input}, {finMem, p})

end


--------------------------------------------------------------------------------
-- Creates model based only on memory
--------------------------------------------------------------------------------
function Model.__createNoInput(opt)
   local vectorSize = tonumber(opt.vectorSize)
   local memSize = tonumber(opt.memorySize)
   local RNN_size = 5 -- TODO add command line param
   ----------------------------------------------------------------------------
   --  Initial Memory
   ----------------------------------------------------------------------------
   local initialMem = nn.Identity()()
   ----------------------------------------------------------------------------


   ----------------------------------------------------------------------------
   --  Address Encoder
   ----------------------------------------------------------------------------
   local reshapedMem = nn.Reshape(memSize * vectorSize)(initialMem)
   local enc = nn.GRU(memSize * vectorSize, memSize, RNN_size)(reshapedMem)
   local address = nn.SoftMax()(enc)
   ----------------------------------------------------------------------------


   ----------------------------------------------------------------------------
   -- Value Extractor
   ----------------------------------------------------------------------------
   --TODO for current problems may not need to send value here
   local addressTransp = nn.Reshape(1, memSize)(address)
   local value = nn.MM()({addressTransp, initialMem})
   ----------------------------------------------------------------------------

   ----------------------------------------------------------------------------
   ---- Next address calculator
   ----------------------------------------------------------------------------
   local reshapedValue = nn.Squeeze(1)(value)
   local valAddr = nn.JoinTable(1)({address, reshapedValue})
   local addrCalc =
   nn.GRU(memSize + vectorSize, memSize, RNN_size)(valAddr)
   ----------------------------------------------------------------------------


   ----------------------------------------------------------------------------
   ---- Next value calculator
   ----------------------------------------------------------------------------
   local valueCalc =
   nn.GRU(memSize + vectorSize, vectorSize, RNN_size)(valAddr)
   ----------------------------------------------------------------------------


   ----------------------------------------------------------------------------
   ---- Memory Calculator
   ----------------------------------------------------------------------------

   ----adder
   local resizeValueCalc = nn.Reshape(1, vectorSize)(valueCalc)
   local resizeAddrCalc = nn.Reshape(memSize, 1)(addrCalc)
   local adder = nn.MM()({resizeAddrCalc, resizeValueCalc})


   ---- eraser
   local addrCalcTransp = nn.Reshape(1, memSize)(addrCalc)
   local AT_M_t_1 =  nn.MM()({addrCalcTransp, initialMem})
   local resAddrCalc = nn.Reshape(memSize, 1)(addrCalc)
   local AAT_M_t_1 = nn.MM()({resAddrCalc, AT_M_t_1})

   ----memory update
   local memEraser = nn.CSubTable()({initialMem, AAT_M_t_1})
   local finMem = nn.Sigmoid()(nn.CAddTable()({memEraser, adder}))
   ----------------------------------------------------------------------------


   ----------------------------------------------------------------------------
   ---- Probability calculator
   ----------------------------------------------------------------------------
   local addrValCalc = nn.JoinTable(1)({addrCalc, valueCalc})
   local allInOne = nn.JoinTable(1)({addrValCalc, reshapedMem})
   -- TODO change this to anything you want
   local h1 = nn.Linear(vectorSize + memSize + memSize * vectorSize, 10)
   (allInOne)

   local p = nn.Sigmoid()(nn.Linear(10, 1)(nn.Sigmoid()(nn.Linear(10, 10)(
   nn.Sigmoid()(h1)))))
   ----------------------------------------------------------------------------

   return nn.gModule({initialMem}, {finMem, p})


end


--------------------------------------------------------------------------------
-- Save model to file
-- Specify overWrite = true if you wish to overwrite an existent file
--------------------------------------------------------------------------------
function Model.saveModel(model, fileName, overWrite)
   --TODO remove hardcoding
   if fileName == nil then
      fileName = "autosave.model"
   end
   if (path.exists(fileName) and overWrite == false) then
      print("file "..fileName.." already exists, overWrite option not specified. aborting.")
      return false
   end
   torch.save(fileName, model)
   print("Saved model!")
   return true
end

--------------------------------------------------------------------------------
-- Load a model from a file
--------------------------------------------------------------------------------
function Model.loadModel(fileName)
   if not path.exists(fileName) then
      print("file "..fileName.." does not exist. Create it first before loading something from it")
      return nil
   end
   model = torch.load(fileName)
   return model
end



return Model
